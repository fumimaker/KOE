/*
                                 \ TANOSHI---!!!!! /
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMF   TMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMB^   ?MMMMMMMMMM
  MMMMMMMMMt       ?WMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM"!       4MMMMMMMMM
  MMMMMMMMF           ?WMMMMMMW""!`              ?""HMMMMMM#"`           MMMMMMMMM
  MMMMMMMM:              ?^                            -""               (MMMMMMMM
  MMMMMMMM.                                                              ,MMMMMMMM
  MMMMMMMM|                                                              (MMMMMMMM
  MMMMMMMMN                                                             .MMMMMMMMM
  MMMMMMMMMN.                                                          .MMMMMMMMMM
  MMMMMMMMMMMa.                                                       .MMMMMMMMMMM
  MMMMMMMMMMMD                                                        ?MMMMMMMMMMM
  MMMMMMMMMM3                                                          ,MMMMMMMMMM
  MMMMMMMMM%                       ...gNNMMNNgJ..                       .MMMMMMMMM
  MMMMMMMMF                     .gMMMMMMMMMMMMMMMMa,                     ,MMMMMMMM
  MMMMMMM#                    .MMMMMMMMMMMMMMMMMMMMMN,                    dMMMMMMM
  MMMMMMM%                  .MMMMMMMMMMH""HMMMMMMMMMMMN.                   MMMMMMM
  MMMMMM#                  .MMMMMMMD!         ?WMMMMMMMN.                  JMMMMMM
  MMMMMMF                  MMMMMMD              ,MMMMMMMb                  .MMMMMM
  MMMMMM]                 .MMMMMF                .MMMMMMM,                  MMMMMM
  MMMMMM%                 (MMMMM\                 JMMMMMM]                  MMMMMM
  MMMMMM]                 (MMMMM)                 .MMMMMMF                  dMMMMM
  MMMMMM]                 .MMMMM%                 .MMMMMM]                  dMMMMM
  MMMMMMb                  ."MM"                  .MMMMMM!                  MMMMMM
  MMMMMMN                                         (MMMMMD                  .MMMMMM
  MMMMMMM[                                       .MMMMB`                   -MMMMMM
  MMMMMMMN,                                      JMMMF                     MMMMMMM
  MMMMMMMMN.                                    -MMMM`                    -MMMMMMM
  MMMMMMMMMN,                                  JMMMM#                    .MMMMMMMM
  MMMMMMMMMMMa.                              .MMMMMMM,                  .MMMMMMMMM
  MMMMMMMMMMMMMa.                          .dMMMMMMMMN.                .MMMMMMMMMM
  MMMMMMMMMMMMMMMN,.                    ..MMMMMMMMMMMMN,             .MMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMN-..          ...gMMMMMMMMMMMMMMMMMNJ.       .+MMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
                                Powered by Arduino
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMB"7`     `?7TMMMMMMMMMMMMMMMMMMMMM#""!`     _7TMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMM#=                 ,TMMMMMMMMMMMMM#"                 .TMMM] -,MMMMMM
  MMMMMMMMMM@`                      ,HMMMMMMMMD`                      /MNggMMMMMMM
  MMMMMMMM#!       ..gNMMMNgJ.        .HMMMMF        ..JgMMMNNa,.       ?MMMMMMMMM
  MMMMMMMF      ..MMMMMMMMMMMMMN,       /M#!      ..MMMMMMMMMMMMMN,      .MMMMMMMM
  MMMMMM@      .MMMMMMMMMMMMMMMMMN,             .(MMMMMMMMMMMMMMMMMN.     ,MMMMMMM
  MMMMMM>     .MMMMMMMMMMMMMMMMMMMMN,          .MMMMMMMM#   MMMMMMMMN,     JMMMMMM
  MMMMM#     .MMMMMM""""""""""MMMMMMMe        JMMMMMM#""5   T""UMMMMMb     .MMMMMM
  MMMMMF     .MMMMMN          MMMMMMMM^      dMMMMMMM[         .MMMMM#      MMMMMM
  MMMMMN     .MMMMMMNNNNNNNNNNMMMMMMM^        TMMMMMMNNNm   qNNMMMMMMF     .MMMMMM
  MMMMMM,     (MMMMMMMMMMMMMMMMMMMM@`          ,MMMMMMMM#   MMMMMMMM#`     JMMMMMM
  MMMMMMN.     ,MMMMMMMMMMMMMMMMM#^      .       7MMMMMMMMMMMMMMMMM@      .MMMMMMM
  MMMMMMMN.      ?MMMMMMMMMMMMMD!       .MN,       ?WMMMMMMMMMMMM@'      .MMMMMMMM
  MMMMMMMMN,        ("""M"""^         .MMMMMN,        .7T"WY"""`        (MMMMMMMMM
  MMMMMMMMMMN,                     ..MMMMMMMMMN,                      .MMMMMMMMMMM
  MMMMMMMMMMMMNa.               ..MMMMMMMMMMMMMMMa.                .gMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMNg(........gNMMMMMMMMMMMMMMMMMMMMMNNg........(gMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMM\  (MMM]     _4M#     (TMM  .MM: .MF       MF  ,MM} .MM=    ?MMMMMMMMM
  MMMMMMMMMF .  HMM]  MN;  M#  MNe  JM  .MM: .MMMM  .MMMF   .M} .M` .MN. .MMMMMMMM
  MMMMMMMMM` Jc .MM]  ??  .M#  MMM  .M  .MM: .MMMM  .MMMF  e .: .#  .MM]  MMMMMMMM
  MMMMMMMM$      JM]  +. .MM#  MMF  -M. .MM! .MMMM  .MMMF  Mp   .M. .MM! .MMMMMMMM
  MMMMMMM@  JMM[  M]  MN, .M#     ..MMh.    .MMF       MF  MMp  .MN.    .MMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM




  K.O.E. LED Strip System Rev.5.10

  Author: Fumiaki Mizuno 17 あっきー

  Date: 2017/12/08

  Memo: このプログラムは冬コン2017に向けてカスタマイズされたものです。
  汚く、保守性を考えていないコードを書いて申し訳ありません。



*/

/////////////////インクルードファイル/////////////////////
#include <Adafruit_NeoPixel.h>

/////////////////インクルードファイル/////////////////////
#ifdef __AVR__
#include <avr/power.h>
#endif

/////////////////定義/////////////////////
#define LEDLINE1 5
#define LEDLINE2 6
#define LEDLINE3 10
#define DEBUG_LED 2
#define PSW1 11
#define PSW2 12

#define LEDLINE1_NUM 75
#define LEDLINE2_NUM 102
#define LEDLINE3_NUM 125

/////////////////インタンス生成/////////////////////
Adafruit_NeoPixel ledline1 = Adafruit_NeoPixel(LEDLINE1_NUM, LEDLINE1, NEO_GRB + NEO_KHZ800);
Adafruit_NeoPixel ledline2 = Adafruit_NeoPixel(LEDLINE2_NUM, LEDLINE2, NEO_GRB + NEO_KHZ800);
Adafruit_NeoPixel ledline3 = Adafruit_NeoPixel(LEDLINE3_NUM, LEDLINE3, NEO_GRB + NEO_KHZ800);
/////////////////グローバル変数宣言/////////////////////
char mode = '0';
boolean spacemode = false, pressmode = false;
boolean mode_flg = false;

/////////////////プロトタイプ宣言/////////////////////
void specialCode  ( void );
void ledShow      ( void );
void colorWipe    (uint32_t c, uint16_t wait);
void rainbow      (uint8_t wait);
void rainbowCycle (uint16_t wait);
void theaterChase (uint32_t c, uint16_t wait);
void theaterChaseRainbow(uint16_t wait);
uint32_t Wheel    (byte WheelPos);

void fadeChange           (uint8_t R, uint8_t G, uint8_t B, uint16_t wait);
void fadeAllOff           (uint16_t wait);
void patAllOn             (uint8_t r, uint8_t g, uint8_t b);
void patAllOff            (void);
void patOnLine            (uint8_t r, uint8_t g, uint8_t b, uint8_t column_num);
void patOffLine           (uint8_t line_num);
void sendResponce         (void);
void fadeChangeBrightness ( uint8_t now_brightness, uint8_t brightness, uint16_t wait );
uint8_t SerialWaitRead    ( void );
void Serial_flush         ( void ); 
void colorWipeBothside    ( void );

void ASUPANIMODE    ( void );
void BISEIBUTSUMODE ( void );
void YUSHAMODE      ( void );
void GROOOOOOTMODE  ( void );
void LOLLIPOPMODE   ( void );
void LEAKMODE       ( void );
void LEMONMODE      ( void );
void TOKKIMODE      ( void );

/////////////////LED制御関数/////////////////////
void specialCode( void ){

  #if defined(__AVR_ATtiny85__)
    if (F_CPU == 16000000)
      clock_prescale_set(clock_div_1);
  #endif
}

void ledShow(void){
  ledline1.show();
  ledline2.show();
  ledline3.show();
}

void colorWipe(uint32_t c, uint16_t wait){
  for (uint16_t i = 0; i < ledline1.numPixels(); i++)
  {
    ledline1.setPixelColor(i, c);
    ledline1.show();
    delay(wait);
    if (Serial.available() > 0)
    {
      break;
    }
  }
  for (uint16_t i = 0; i < ledline2.numPixels(); i++)
  {
    ledline2.setPixelColor(i, c);
    ledline2.show();
    delay(wait);
    if (Serial.available() > 0)
    {
      break;
    }
  }
  for (uint16_t i = 0; i < ledline3.numPixels(); i++)
  {
    ledline3.setPixelColor(i, c);
    ledline3.show();
    delay(wait);
    if (Serial.available() > 0)
    {
      break;
    }
  }
}

void rainbow(uint8_t wait){
  uint16_t i, j;

  for (j = 0; j < 256; j++)
  {
    for (i = 0; i < ledline1.numPixels(); i++)
    {
      ledline1.setPixelColor(i, Wheel((i + j) & 255));
    }
    for (i = 0; i < ledline2.numPixels(); i++)
    {
      ledline2.setPixelColor(i, Wheel((i + j) & 255));
    }
    for (i = 0; i < ledline3.numPixels(); i++)
    {
      ledline3.setPixelColor(i, Wheel((i + j) & 255));
    }
    ledShow();
    delay(wait);
    if (Serial.available() > 0)
    {
      break;
    }
  }
}

void rainbowCycle(uint16_t wait){
  uint16_t i, j;

  for (j = 0; j < 256 * 5; j++)
  { // 5 cycles of all colors on wheel
    for (i = 0; i < ledline1.numPixels(); i++)
    {
      ledline1.setPixelColor(i, Wheel(((i * 256 / ledline1.numPixels()) + j) & 255));
    }
    for (i = 0; i < ledline2.numPixels(); i++)
    {
      ledline2.setPixelColor(i, Wheel(((i * 256 / ledline2.numPixels()) + j) & 255));
    }
    for (i = 0; i < ledline3.numPixels(); i++)
    {
      ledline3.setPixelColor(i, Wheel(((i * 256 / ledline3.numPixels()) + j) & 255));
    }
    ledShow();
    delay(wait);
    if (Serial.available() > 0)
    {
      break;
    }
  }
}

//Theatre-style crawling lights.
void theaterChase(uint32_t c, uint16_t wait){
  for (int j = 0; j < 10; j++)
  { //do 10 cycles of chasing
    for (int q = 0; q < 3; q++)
    {
      for (uint16_t i = 0; i < ledline1.numPixels(); i = i + 3)
      {
        ledline1.setPixelColor(i + q, c); //turn every third pixel on
      }
      ledline1.show();

      delay(wait);

      for (uint16_t i = 0; i < ledline1.numPixels(); i = i + 3)
      {
        ledline1.setPixelColor(i + q, 0); //turn every third pixel off
      }
    }
  }
}

//Theatre-style crawling lights with rainbow effect
void theaterChaseRainbow(uint16_t wait){
  for (int j = 0; j < 256; j++)
  { // cycle all 256 colors in the wheel
    for (int q = 0; q < 3; q++)
    {
      for (uint16_t i = 0; i < ledline1.numPixels(); i = i + 3)
      {
        ledline1.setPixelColor(i + q, Wheel((i + j) % 255)); //turn every third pixel on
      }
      ledline1.show();

      delay(wait);

      for (uint16_t i = 0; i < ledline1.numPixels(); i = i + 3)
      {
        ledline1.setPixelColor(i + q, 0); //turn every third pixel off
      }
    }
  }
}

// Input a value 0 to 255 to get a color value.
// The colours are a transition r - g - b - back to r.
uint32_t Wheel(byte WheelPos){
  WheelPos = 255 - WheelPos;
  if (WheelPos < 85)
  {
    return ledline1.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  }
  if (WheelPos < 170)
  {
    WheelPos -= 85;
    return ledline1.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  }
  WheelPos -= 170;
  return ledline1.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
}

void fadeChange(uint8_t R, uint8_t G, uint8_t B, uint16_t wait){
  boolean R_flg = true, G_flg = true, B_flg = true;
  ledline1.setBrightness(255);
  ledline2.setBrightness(255);
  ledline3.setBrightness(255);
  while ((R_flg == true) || (G_flg == true) || (B_flg == true))
  { //全ての値が目標値に到達していなかったら
    uint32_t color = ledline1.getPixelColor(0);

    uint8_t now_R1 = (color >> 16);
    uint8_t now_G1 = (color >> 8);
    uint8_t now_B1 = (color);

    uint8_t now_R2 = (color >> 16);
    uint8_t now_G2 = (color >> 8);
    uint8_t now_B2 = (color);

    uint8_t now_R3 = (color >> 16);
    uint8_t now_G3 = (color >> 8);
    uint8_t now_B3 = (color);

    int16_t diff_R1;
    int16_t diff_G1;
    int16_t diff_B1;

    int16_t diff_R2;
    int16_t diff_G2;
    int16_t diff_B2;

    int16_t diff_R3;
    int16_t diff_G3;
    int16_t diff_B3;
    for (int16_t i = 0; i < ledline1.numPixels(); i++)
    { //するまでやる

      diff_R1 = R - now_R1;
      diff_G1 = G - now_G1;
      diff_B1 = B - now_B1;

      if (diff_R1 > 0)
      { //目標値のほうがが大きいので明るさを増やす
        now_R1++;
      }
      else if (diff_R1 < 0)
      { //目標値の方が小さいので明るさを減らす
        now_R1--;
      }
      else if (diff_R1 == 0)
      { //目標値と現在の明るさが一致しているのでOK
        R_flg = false;
      }

      if (diff_G1 > 0)
      {
        now_G1++;
      }
      else if (diff_G1 < 0)
      {
        now_G1--;
      }
      else if (diff_G1 == 0)
      {
        G_flg = false;
      }

      if (diff_B1 > 0)
      {
        now_B1++;
      }
      else if (diff_B1 < 0)
      {
        now_B1--;
      }
      else if (diff_B1 == 0)
      {
        B_flg = false;
      }
      ledline1.setPixelColor(i, now_R1, now_G1, now_B1);
    }
    for (int16_t i = 0; i < ledline2.numPixels(); i++)
    { //するまでやる
      diff_R2 = R - now_R2;
      diff_G2 = G - now_G2;
      diff_B2 = B - now_B2;

      if (diff_R2 > 0)
      { //目標値のほうがが大きいので明るさを増やす
        now_R2++;
      }
      else if (diff_R2 < 0)
      { //目標値の方が小さいので明るさを減らす
        now_R2--;
      }
      else if (diff_R2 == 0)
      { //目標値と現在の明るさが一致しているのでOK
        R_flg = false;
      }

      if (diff_G2 > 0)
      {
        now_G2++;
      }
      else if (diff_G2 < 0)
      {
        now_G2--;
      }
      else if (diff_G2 == 0)
      {
        G_flg = false;
      }

      if (diff_B2 > 0)
      {
        now_B2++;
      }
      else if (diff_B2 < 0)
      {
        now_B2--;
      }
      else if (diff_B2 == 0)
      {
        B_flg = false;
      }
      ledline2.setPixelColor(i, now_R2, now_G2, now_B2);
    }
    for (int16_t i = 0; i < ledline3.numPixels(); i++)
    { //するまでやる

      diff_R3 = R - now_R3;
      diff_G3 = G - now_G3;
      diff_B3 = B - now_B3;

      if (diff_R3 > 0)
      { //目標値のほうがが大きいので明るさを増やす
        now_R3++;
      }
      else if (diff_R3 < 0)
      { //目標値の方が小さいので明るさを減らす
        now_R3--;
      }
      else if (diff_R3 == 0)
      { //目標値と現在の明るさが一致しているのでOK
        R_flg = false;
      }

      if (diff_G3 > 0)
      {
        now_G3++;
      }
      else if (diff_G3 < 0)
      {
        now_G3--;
      }
      else if (diff_G3 == 0)
      {
        G_flg = false;
      }

      if (diff_B3 > 0)
      {
        now_B3++;
      }
      else if (diff_B3 < 0)
      {
        now_B3--;
      }
      else if (diff_B3 == 0)
      {
        B_flg = false;
      }
      ledline3.setPixelColor(i, now_R3, now_G3, now_B3);
    }
    ledline1.show();
    ledline2.show();
    ledline3.show();
    delay(wait);
  }
}

void fadeAllOff(uint16_t wait){
  for (signed int k = 255; k >= 0; k = k - 10)
  {
    ledline1.setBrightness(k);
    ledline2.setBrightness(k);
    ledline3.setBrightness(k);
    ledline1.show();
    ledline2.show();
    ledline3.show();
    delay(wait);
  }
  for (signed int i = 0; i < ledline1.numPixels(); i++)
  {
    ledline1.setPixelColor(i, 0, 0, 0);
  }
  for (signed int i = 0; i < ledline2.numPixels(); i++)
  {
    ledline2.setPixelColor(i, 0, 0, 0);
  }
  for (signed int i = 0; i < ledline3.numPixels(); i++)
  {
    ledline3.setPixelColor(i, 0, 0, 0);
  }
  ledline1.setBrightness(255);
  ledline2.setBrightness(255);
  ledline3.setBrightness(255);
  ledline1.show();
  ledline2.show();
  ledline3.show();
}

void patAllOn(uint8_t r, uint8_t g, uint8_t b){
  for (uint16_t a = 0; a < ledline1.numPixels(); a++)
  {
    ledline1.setPixelColor(a, r, g, b);
  }
  for (uint16_t a = 0; a < ledline2.numPixels(); a++)
  {
    ledline2.setPixelColor(a, r, g, b);
  }
  for (uint16_t a = 0; a < ledline3.numPixels(); a++)
  {
    ledline3.setPixelColor(a, r, g, b);
  }
  Serial.println("patAllOn");
  ledline1.setBrightness(255);
  ledline2.setBrightness(255);
  ledline3.setBrightness(255);
  ledShow();
}

void patAllOff(void){
  for (int a = 0; a < ledline1.numPixels(); a++)
  {
    ledline1.setPixelColor(a, 0, 0, 0);
  }
  for (int a = 0; a < ledline2.numPixels(); a++)
  {
    ledline2.setPixelColor(a, 0, 0, 0);
  }
  for (int a = 0; a < ledline3.numPixels(); a++)
  {
    ledline3.setPixelColor(a, 0, 0, 0);
  }
  ledShow();
}

void patOnLine(uint8_t r, uint8_t g, uint8_t b, uint8_t column_num){ //列単位で点灯します。
  int16_t i = 0;
  if (column_num == 1)
  {
    for (i = 0; i < ledline1.numPixels(); i++)
    {
      ledline1.setPixelColor(i, r, g, b);
    }
  }
  else if (column_num == 2)
  {
    for (i = 0; i < ledline2.numPixels(); i++)
    {
      ledline2.setPixelColor(i, r, g, b);
    }
  }
  else if (column_num == 3)
  {
    for (i = 0; i < ledline3.numPixels(); i++)
    {
      ledline3.setPixelColor(i, r, g, b);
    }
  }
  ledShow();
}

void patOffLine(uint8_t line_num){ //列単位で消灯します
  int16_t i = 0;
  if (line_num == 1)
  {
    for (i = 0; i < ledline1.numPixels(); i++)
    {
      ledline1.setPixelColor(i, 0, 0, 0);
    }
  }
  else if (line_num == 2)
  {
    for (i = 0; i < ledline2.numPixels(); i++)
    {
      ledline2.setPixelColor(i, 0, 0, 0);
    }
  }
  else if (line_num == 3)
  {
    for (i = 0; i < ledline3.numPixels(); i++)
    {
      ledline3.setPixelColor(i, 0, 0, 0);
    }
  }
  ledShow();
}

void fadeChangeBrightness(uint8_t now_brightness, uint8_t brightness, uint16_t wait){
  if ((brightness - now_brightness) > 0)
  {
    for (int i = now_brightness + 1; i <= brightness; i++)
    {
      ledline1.setBrightness(i);
      ledline2.setBrightness(i);
      ledline3.setBrightness(i);
      ledShow();
      delay(wait);
    }
  }
  else if ((brightness - now_brightness) < 0)
  {
    for (int i = now_brightness; i >= brightness; i--)
    {
      ledline1.setBrightness(i);
      ledline2.setBrightness(i);
      ledline3.setBrightness(i);
      ledShow();
      delay(wait);
    }
  }
}

void sendResponce(void){
  Serial.print("OK");
}

uint8_t SerialWaitRead(void){
  while (Serial.available() == 0);
  Serial.println("Waiting command");
  uint8_t commingInByte = Serial.read();
  Serial_flush();
  return commingInByte;
}

void Serial_flush(void){
  while (Serial.available() > 0)
  {
    uint8_t trashByte = Serial.read();
  }
  Serial.println("SerialFlush");
}

void colorWipeBothside( void ){
  uint16_t times = 0;
  Serial_flush();
  for (times = 0; times < ledline1.numPixels() / 2; times++)
  {
    ledline1.setPixelColor(ledline1.numPixels() - times, 0, 0, 255);
    ledline1.setPixelColor(times, 0, 0, 255);
    ledline1.show();
    delay(40);
  }
  for (times = 0; times < ledline2.numPixels() / 2; times++)
  {
    ledline2.setPixelColor(ledline2.numPixels() - times, 0, 0, 255);
    ledline2.setPixelColor(times, 0, 0, 255);
    ledline2.show();
    delay(40);
  }
  for (times = 0; times < ledline3.numPixels() / 2; times++)
  {
    ledline3.setPixelColor(ledline3.numPixels() - times, 0, 0, 255);
    ledline3.setPixelColor(times, 0, 0, 255);
    ledline3.show();
    delay(40);
  }
  patAllOn(0, 0, 255);
}

/////////////////バンド関数/////////////////////

void ASUPANIMODE(void){
  Serial.println("あすかが突然パニックモードに入りました。");
  Serial.println("入り方：（よっぴーパーカス）どんつ1どんつ2どどん3どどん4 5パラGO");
  Serial.println("0x20, 1左, 2右, 3全点灯, 4流れ星");
  mode_flg = true;
  uint8_t num = 0;
  int32_t i = 0;
  char str = 0;

  #define ONLEDNUM 25

  while (mode_flg)
  {
    if (Serial.available() > 0)
    {
      str = Serial.read();
    }
    else
      str = 0; //なにも来てなかったら何も動かさない
    if (str == 0x20)
    {
      if (num >= 20)
        num = 0; //2回目以降

      if (num == 0 || num == 4 || num == 8)
        patOnLine(0, 0, 255, 1);
      else if (num == 1 || num == 5 || num == 9)
        patOnLine(0, 0, 255, 2);
      else if (num == 2 || num == 6 || num == 10)
        patOnLine(0, 0, 255, 3);
      else if (num == 3 || num == 7 || num == 11)
        patAllOff();
      else if (num >= 12 && num <= 15)
      {
        patAllOn(255, 255, 255);
        delay(100);
        patAllOff();
      }
      else if (num == 16)
        patOnLine(255, 0, 0, 3);
      else if (num == 17)
        patOnLine(0, 255, 0, 2);
      else if (num == 18)
        patOnLine(0, 0, 255, 1);
      else if (num == 19)
        patAllOn(255, 255, 255);
      num++;
      sendResponce();
    }

    else if (str == '1')
    {
      patAllOff();
      for (i = 0; i < ONLEDNUM; i++)
      {
        ledline1.setPixelColor(i, 0, 0, 255); //1列目左端ONLEDNUM個点灯
      }
      for (i = 0; i < ONLEDNUM; i++)
      { //2列目左端ONLEDMUN個点灯
        ledline2.setPixelColor(i, 0, 0, 255);
      }
      for (i = 0; i < ONLEDNUM; i++)
      { //3列目左ONLEDNUM個点灯
        ledline3.setPixelColor(i, 0, 0, 255);
      }
      ledShow();
      delay(500);
      patAllOff();
      sendResponce();
      num = 0;
    }

    else if (str == '2')
    {
      patAllOff();
      for (i = ledline1.numPixels() - ONLEDNUM; i < ledline1.numPixels(); i++)
      {
        ledline1.setPixelColor(i, 0, 0, 255); //1列目migi端ONLEDNUM個点灯
      }
      for (i = ledline2.numPixels() - ONLEDNUM; i < ledline2.numPixels(); i++)
      { //2列目migi端ONLEDMUN個点灯
        ledline2.setPixelColor(i, 0, 0, 255);
      }
      for (i = ledline3.numPixels() - ONLEDNUM; i < ledline3.numPixels(); i++)
      { //3列目migiONLEDNUM個点灯
        ledline3.setPixelColor(i, 0, 0, 255);
      }
      ledShow();
      delay(500);
      patAllOff();
      sendResponce();
      num = 0;
    }

    else if (str == '3')
    {
      patAllOn(255, 255, 255);
      delay(200);
      fadeAllOff(0);
      sendResponce();
    }

    else if (str == '4')
    { //もしかしたらcolorWipeでも良いかもしれない。
      boolean quit_flg = true;
      Serial_flush();
      while (quit_flg)
      {
        if (Serial.available() > 0)
        {
          quit_flg = false; //while条件終わり
        }
        colorWipe(ledline1.Color(255, 255, 0), 2);
        if (Serial.available() > 0)
        {                   //str=3のループを抜けて今来たバイトを先頭に戻って読ませる。
          quit_flg = false; //while条件終わり
        }
        colorWipe(ledline1.Color(0, 255, 255), 2);
        if (Serial.available() > 0)
        {                   //str=3のループを抜けて今来たバイトを先頭に戻って読ませる。
          quit_flg = false; //while条件終わり
        }
        colorWipe(ledline1.Color(255, 0, 255), 2);
        if (Serial.available() > 0)
        {                   //str=3のループを抜けて今来たバイトを先頭に戻って読ませる。
          quit_flg = false; //while条件終わり
        }
        sendResponce();
      }
    }
    else if (str == '5')
    {
      patAllOff();
      for (i = 0; i < ONLEDNUM; i++)
      {
        ledline1.setPixelColor(i, 255, 0, 255); //1列目左端ONLEDNUM個点灯
      }
      for (i = 0; i < ONLEDNUM; i++)
      { //2列目左端ONLEDMUN個点灯
        ledline2.setPixelColor(i, 255, 0, 255);
      }
      for (i = 0; i < ONLEDNUM; i++)
      { //3列目左ONLEDNUM個点灯
        ledline3.setPixelColor(i, 255, 0, 255);
      }
      ledShow();
      delay(300);
      patAllOff();
      sendResponce();
    }
    else if (str == '6')
    {
      patAllOff();
      for (i = (ledline1.numPixels() / 2) - (ONLEDNUM / 2); i < (ledline1.numPixels() / 2) + (ONLEDNUM / 2); i++)
      {
        ledline1.setPixelColor(i, 255, 0, 255); //1列目中央ONLEDNUM個点灯
      }
      for (i = (ledline2.numPixels() / 2) - (ONLEDNUM / 2); i < (ledline2.numPixels() / 2) + (ONLEDNUM / 2); i++)
      {
        ledline2.setPixelColor(i, 255, 0, 255); //1列目中央ONLEDNUM個点灯
      }
      for (i = (ledline3.numPixels() / 2) - (ONLEDNUM / 2); i < (ledline3.numPixels() / 2) + (ONLEDNUM / 2); i++)
      {
        ledline3.setPixelColor(i, 255, 0, 255); //1列目中央ONLEDNUM個点灯
      }
      ledShow();
      delay(300);
      patAllOff();
      sendResponce();
    }
    else if (str == '7')
    {
      patAllOff();
      for (i = ledline1.numPixels() - ONLEDNUM; i < ledline1.numPixels(); i++)
      {
        ledline1.setPixelColor(i, 255, 0, 255); //1列目migi端ONLEDNUM個点灯
      }
      for (i = ledline2.numPixels() - ONLEDNUM; i < ledline2.numPixels(); i++)
      { //2列目migi端ONLEDMUN個点灯
        ledline2.setPixelColor(i, 255, 0, 255);
      }
      for (i = ledline3.numPixels() - ONLEDNUM; i < ledline3.numPixels(); i++)
      { //3列目migiONLEDNUM個点灯
        ledline3.setPixelColor(i, 255, 0, 255);
      }
      ledShow();
      delay(300);
      patAllOff();
      sendResponce();
    }

    else if (str == '8')
    {
      fadeAllOff(5);
      sendResponce();
      Serial.println("End of ASUPANIMODE. Please Quit");
    }
    else if (str == 'q')
    {
      mode_flg = false;
      sendResponce();
      Serial.println("Quit ASUPANIMODE");
      Serial_flush();
    }
  }
}

void BISEIBUTSUMODE(void){
  Serial.println("微生物モードに入りました。");
  Serial.println("入り方：なーつがあーつがのーのーのー");
  Serial.println("");
  mode_flg = true;
  uint8_t num = 0;
  int32_t i = 0;
  char str = 0;
  #define ONLEDNUM 20
  while (mode_flg)
  {
    if (Serial.available() > 0)
    {
      str = Serial.read();
      Serial_flush();
    }
    else
      str = 0; //なにも来てなかったら何も動かさない

    switch (str)
    {
    case 0x20:
    {
      fadeAllOff(50);
      num = 0;
      sendResponce();
      break;
    }
    case '0':
    { //なーつがあーつがのーのーのー
      patAllOn(255, 255, 255);
      delay(200);
      fadeAllOff(5);
      sendResponce();
      break;
    }

    case '1':
    {
      if (num == 0)
      {
        patOffLine(1);
        patOffLine(2);
        patOnLine(255, 0, 0, 3);
        sendResponce();
      }
      else if (num == 1)
      {
        patOffLine(1);
        patOnLine(255, 0, 0, 2);
        patOffLine(3);
        sendResponce();
      }
      else if (num == 2)
      {
        patOnLine(255, 0, 0, 1);
        patOffLine(2);
        patOffLine(3);
        sendResponce();
      }
      else if (num == 3)
      {
        patAllOff();
        sendResponce();
      }
      num++;
      if (num > 3)
      {
        num = 0;
      }
      break;
    }

    case '2':
    { //青左右から迫ってくる
      uint16_t times = 0;
      Serial_flush();
      for (times = 0; times < ledline1.numPixels() / 2; times++)
      {
        ledline1.setPixelColor(ledline1.numPixels() - times, 0, 0, 255);
        ledline1.setPixelColor(times, 0, 0, 255);
        ledline1.show();
        delay(40);
      }
      for (times = 0; times < ledline2.numPixels() / 2; times++)
      {
        ledline2.setPixelColor(ledline2.numPixels() - times, 0, 0, 255);
        ledline2.setPixelColor(times, 0, 0, 255);
        ledline2.show();
        delay(40);
      }
      for (times = 0; times < ledline3.numPixels() / 2; times++)
      {
        ledline3.setPixelColor(ledline3.numPixels() - times, 0, 0, 255);
        ledline3.setPixelColor(times, 0, 0, 255);
        ledline3.show();
        delay(40);
      }
      patAllOn(0, 0, 255);
      break;
    }

    case '3':
    { //左点灯
      patAllOff();
      for (i = 0; i < ONLEDNUM; i++)
      {
        ledline1.setPixelColor(i, 255, 0, 0); //1列目左端ONLEDNUM個点灯
      }
      for (i = 0; i < ONLEDNUM; i++)
      { //2列目左端ONLEDMUN個点灯
        ledline2.setPixelColor(i, 255, 0, 0);
      }
      for (i = 0; i < ONLEDNUM; i++)
      { //3列目左ONLEDNUM個点灯
        ledline3.setPixelColor(i, 255, 0, 0);
      }
      ledShow();
      delay(500);
      patAllOff();
      sendResponce();
      break;
    }

    case '4':
    {
      for (i = ledline1.numPixels() - ONLEDNUM; i < ledline1.numPixels(); i++)
      {
        ledline1.setPixelColor(i, 255, 0, 0); //1列目Right端15個点灯
      }
      for (i = ledline2.numPixels() - ONLEDNUM; i < ledline2.numPixels(); i++)
      {
        ledline2.setPixelColor(i, 255, 0, 0); //1列目Right端15個点灯
      }
      for (i = ledline3.numPixels() - ONLEDNUM; i < ledline3.numPixels(); i++)
      {
        ledline3.setPixelColor(i, 255, 0, 0); //1列目Right端15個点灯
      }
      ledShow();
      delay(500);
      patAllOff();
      sendResponce();
      break;
    }

    case '5':
    {
      if (num == 0)
      {
        patOnLine(255, 0, 0, 1);
      }
      else if (num == 1)
      {
        patOffLine(1);
        patOnLine(255, 0, 0, 2);
      }
      else if (num == 2)
      {
        patOffLine(1);
        patOffLine(2);
        patOnLine(255, 0, 0, 3);
      }
      else if (num == 3)
      {
        patAllOn(255, 255, 255);
      }
      num++;
      sendResponce();
      break;
    }

    case '6':
    {
      colorWipe(ledline1.Color(255, 0, 0), 15);
      sendResponce();
      break;
    }

    case '7':
    {
      fadeAllOff(5);
      sendResponce();
      Serial.println("End of BISEIBUTSU. Please quit");
      break;
    }

    case 'q':
    {
      mode_flg = false;
      sendResponce();
      Serial_flush();
      Serial.println("Quit BISEIBUTSUMODE");
    }
    }
  }
}

void YUSHAMODE(void){
  Serial.println("勇者御一行モードに入りました。");
  Serial.println("入り方：LALALA...で0に入る");
  Serial.println("");
  mode_flg = true;
  uint8_t num = 0;
  int32_t i = 0;
  char str = 0;

  while (mode_flg)
  {
    if (Serial.available() > 0)
    {
      str = Serial.read();
      Serial_flush();
    }
    else
      str = 0; //なにも来てなかったら何も動かさない

    switch (str)
    {
    case '0':
    {
  #define ONLEDNUM 25
      byte num = 0;
      boolean quit_flg = true;
      Serial_flush();
      fadeChange(0, 100, 0, 5);

      sendResponce();
      Serial.println("break while");
      break;
    }

    case '1':
    {
      fadeAllOff(5);
      delay(200);
      sendResponce();
      fadeChange(0, 0, 20, 10);
      break;
    }

    case '2':
    {
      uint16_t times = 0;
      Serial_flush();
      for (times = 0; times < ledline1.numPixels() / 2; times++)
      {
        ledline1.setPixelColor(ledline1.numPixels() - times, 255, 0, 0);
        ledline1.setPixelColor(times, 255, 0, 0);
        ledline1.show();
        delay(40);
      }
      for (times = 0; times < ledline2.numPixels() / 2; times++)
      {
        ledline2.setPixelColor(ledline2.numPixels() - times, 255, 0, 0);
        ledline2.setPixelColor(times, 255, 0, 0);
        ledline2.show();
        delay(40);
      }
      for (times = 0; times < ledline3.numPixels() / 2; times++)
      {
        ledline3.setPixelColor(ledline3.numPixels() - times, 255, 0, 0);
        ledline3.setPixelColor(times, 255, 0, 0);
        ledline3.show();
        delay(40);
      }
      patAllOn(255,0,0);
      break;
    }

    case '3':
    {
      fadeAllOff(5);
      sendResponce();
      break;
    }

    case '4':
    {
      patAllOn(254, 254, 0);
      delay(300);
      fadeAllOff(0);
      sendResponce();
      Serial_flush();
      break;
    }

    case '5':
    {
      fadeChange(0, 25, 0, 5);
      sendResponce();
      Serial_flush();
      break;
    }

    case '6':
    { //一人一人挨拶
      byte num = 1;
      boolean quit_flg = true;
      Serial_flush();
      while (quit_flg)
      {
        if (SerialWaitRead() == '6')
        {
          if (num == 0)
            fadeAllOff(1);
          else if (num == 1)
            colorWipe(ledline1.Color(157, 204, 254), 5); //あゆみ
          else if (num == 2)
            colorWipe(ledline1.Color(0, 255, 0), 5); //ぐっちー
          else if (num == 3)
            colorWipe(ledline1.Color(135, 0, 204), 5); //いずみ
          else if (num == 4)
            colorWipe(ledline1.Color(255, 55, 0), 5); //まーしー
          else if (num == 5)
            colorWipe(ledline1.Color(255, 0, 255), 5); //かなみ
          else if (num == 6)
            colorWipe(ledline1.Color(0, 0, 255), 5); //つばさ
          else if (num == 7)
            colorWipe(ledline1.Color(255, 0, 0), 5); //ねぐせ
          else if (num == 8)
          {
            colorWipe(ledline1.Color(0, 0, 0), 10); //消灯
            quit_flg = false;
          }
          num++;
          sendResponce();
          Serial_flush();
        }
      }
      sendResponce();
      break;
    }

    case '7':
    { //最後の礼をするところ ららららーーらーらーらーー
      fadeChange(255, 255, 255, 10);
      ledShow();
      sendResponce();
      Serial.println("8 to fade Trun Off. ");
      break;
    }

    case '8':
    {
      fadeAllOff(5);
      sendResponce();
      Serial.println("Press 'q' to Quit YUSYAMODE");
      break;
    }

    case 'q':
    {
      mode_flg = false;
      sendResponce();
      Serial.println("Quit YUSYAMODE");
      Serial_flush();
      break;
    }

    case 0x20:
    {
      patAllOff();
      sendResponce();
      break;
    }
    }
  }
}

void GROOOOOOTMODE(void){
  Serial.println("Groooootモードにはいりました。");
  Serial.println("入り方：");
  Serial.println("");
  mode_flg = true;
  uint8_t num = 0;
  int32_t i = 0;
  char str = 0;

  while (mode_flg)
  {
    if (Serial.available() > 0)
    {
      str = Serial.read();
      Serial_flush();
    }
    else
      str = 0; //なにも来てなかったら何も動かさない

    switch (str)
    {
    case '0':
    {
      fadeChange(5, 0, 50, 20); //ひさブルー

      sendResponce();
      break;
    }

    case '1':
    {
      fadeChange(255, 0, 5, 20); //akappoi(uptenpo)
      str = 0;
      Serial_flush();
      sendResponce();
      break;
    }

    case '2':
    {
      colorWipe(ledline1.Color(255, 255, 255), 10);
      sendResponce();
      break;
    }

    case '3':
    {
      if (num == 0)
        patOnLine(255, 55, 0, 1);
      else if (num == 1)
        patOnLine(255, 55, 0, 2);
      else if (num == 2)
        patOnLine(255, 55, 0, 3);
      else if (num == 3)
        patAllOn(255, 255, 255);
      num++;
      sendResponce();
      break;
    }

    case '4':
    {
      fadeAllOff(1);
      Serial.println("End of program. Please Quit GROOOOOOTMODE");
      sendResponce();
      break;
    }

    case 0x20:
    {
      fadeAllOff(20);
      sendResponce();
      break;
    }

    case 'q':
      mode_flg = false;
      sendResponce();
      Serial_flush();
      Serial.println("Quit GROOOOOOTMODE");
      break;
    }
  }
}

void LOLLIPOPMODE(void){
  Serial.println("Lillopopモードにはいりました。");
  Serial.println("入り方：");
  Serial.println("");
  mode_flg = true;
  uint8_t num = 0;
  int32_t i = 0;
  char str = 0;

  while (mode_flg)
  {
    if (Serial.available() > 0)
    {
      str = Serial.read();
    }
    else
      str = 0; //なにも来てなかったら何も動かさない
    switch (str)
    {
    case '0':
    {
      fadeChange(255, 0, 200, 20);
      sendResponce();
      break;
    }
    case '1':
    {
      fadeAllOff(40);
      sendResponce();
      break;
    }
    case '2':
    {
      patAllOn( 255, 0, 200 );
      sendResponce();
      break;
    }
    case '3':
    {
      patAllOff();
      Serial.println("end of program. Please quit LOLLIPOPMODE.");
      break;
    }
    case 0x20:
    {
      patAllOff();
      sendResponce();
      break;
    }
    case 'q':
    {
      mode_flg = false;
      sendResponce();
      Serial_flush();
      Serial.println("Quit LOLLIPOPMODE");
    }
    }
  }
}

void LEAKMODE(void){
  Serial.println("LEAKモードにはいりました。");
  Serial.println("入り方：");
  Serial.println("");
  mode_flg = true;
  uint8_t num = 0;
  int32_t i = 0;
  char str = 0;
  #define LEDONNUM 25
  while (mode_flg)
  {
    if (Serial.available() > 0)
    {
      str = Serial.read();
    }
    else
      str = 0; //なにも来てなかったら何も動かさない
    switch (str)
    {
      case '0':
      {
        ledline1.setBrightness(255);
        ledline2.setBrightness(255);
        ledline3.setBrightness(255);
        patAllOn(0, 0, 255);
        break;
      }
      case '1':
      {
        fadeChangeBrightness(255, 50, 2);
        Serial.println("呼吸消えend");
        break;
      }
      case '2':
      {
        fadeChangeBrightness(50, 255, 2);
        Serial.println("呼吸あげend");
        break;
      }
      case '3':
      {
        
        for(int i=0; i<ledline1.numPixels(); i++){
          if(i<LEDONNUM){
            ledline1.setPixelColor(i, 255, 0, 0);
          }
          else{
            ledline1.setPixelColor(i, 0, 0, 128);
          }
        }
        patOffLine(2);
        patOffLine(3);
        ledShow();
        break;
      }
      case '4':
      {
        patAllOff();
        for (int i = 0; i < ledline1.numPixels(); i++)
        {
          if (i < ledline1.numPixels() - LEDONNUM)
          {
            ledline1.setPixelColor(i, 0, 0, 128);
          }
          else
          {
            ledline1.setPixelColor(i, 255, 0, 0);
          }
        }
        patOffLine(2);
        patOffLine(3);
        ledShow();
        break;
      }

      case '5':
      {
        patOnLine(0,0,10,1);
        patOffLine(2);
        patOffLine(3);
        break;
      }

      case '6':{
        patAllOff();
        break;
      }

      case '7':{
        patOnLine(0,0,255,1);
        patOnLine(255, 0, 180, 2);
        patOnLine(0, 0, 255, 3);
        break;
      }

      case '8':{
        fadeAllOff(0);
        break;
      }
      case 0x20:
      {
        ledline1.setBrightness(255);
        ledline2.setBrightness(255);
        ledline3.setBrightness(255);
        patAllOff();
        break;
      }
      case 'q':
      {
        mode_flg = false;
        sendResponce();
        Serial_flush();
        Serial.println("Quit LEAKMODE");
        break;
      }
    }
  }
}

void LEMONMODE(void){
  Serial.println("LEAKモードにはいりました。");
  Serial.println("入り方：");
  Serial.println("");
  mode_flg = true;
  uint8_t num = 0;
  int32_t i = 0;
  char str = 0;
  #define ONLEDNUM 10
  while (mode_flg)
  {
    if (Serial.available() > 0)
    {
      str = Serial.read();
    }
    else
      str = 0; //なにも来てなかったら何も動かさない
    switch (str)
    {
    case '0':
    {
      ledline1.setBrightness(255);
      ledline2.setBrightness(255);
      ledline3.setBrightness(255);
      for (int k = 0; k < 256; k++)
      {
        for (int i = 0; i < ledline2.numPixels(); i++)
        {
          ledline2.setPixelColor(i, k, k, 0);
        }
        ledShow();
        delay(10);
      }
      break;
    }
    case '1':
    {
      fadeChange(255, 255, 0, 50);
      break;
    }
    case '2':
    {
      fadeChange(255, 10, 0, 10);
      ledline1.setBrightness(100);
      ledline2.setBrightness(100);
      ledline3.setBrightness(100);
      ledShow();
      break;
    }
    case '3':
    {
      patAllOff();
      break;
    }
    case '4':
    {
      int wait = 10;
      uint32_t c = ledline1.Color(255, 255, 0);
      patAllOn(255, 0, 0); //orange(weak)
      delay(1800);
      for (uint16_t i = 0; i < ledline3.numPixels(); i++)
      {
        ledline3.setPixelColor(i, c);
        ledline3.show();
        delay(wait);
        if (Serial.available() > 0)
        {
          break;
        }
      }
      for (uint16_t i = 0; i < ledline2.numPixels(); i++)
      {
        ledline2.setPixelColor(i, c);
        ledline2.show();
        delay(wait);
        if (Serial.available() > 0)
        {
          break;
        }
      }
      for (uint16_t i = 0; i < ledline1.numPixels(); i++)
      {
        ledline1.setPixelColor(i, c);
        ledline1.show();
        delay(wait);
        if (Serial.available() > 0)
        {
          break;
        }
      }
      num = 0;
      break;
    }

    case '5':
    { //fire fire fire
      patAllOn(255, 255, 255);
      delay(200);
      patAllOff();
      break;
    }

    case '6':
    { //threre is no going back
      patAllOff();
      for (int i = ledline1.numPixels() - ONLEDNUM; i < ledline1.numPixels(); i++)
      {
        ledline1.setPixelColor(i, 0, 0, 255);
      }
      for (int i = ledline2.numPixels() - ONLEDNUM; i < ledline2.numPixels(); i++)
      {
        ledline2.setPixelColor(i, 0, 0, 255);
      }
      for (int i = ledline3.numPixels() - ONLEDNUM; i < ledline3.numPixels(); i++)
      {
        ledline3.setPixelColor(i, 0, 0, 255);
      }
      ledShow();
      break;
    }
    case '7':
    {
      patAllOn(255, 5, 0);
      fadeChangeBrightness(255, 20, 2);
      fadeChangeBrightness(20, 255, 2);
      Serial.println("呼吸終わり");
      break;
    }

    case '8':
    {
      patAllOff();
      break;
    }
    case '9':
    {
      patAllOn(255, 5, 0);
      break;
    }

    case '-':
    {
      patAllOn(255, 255, 0);
      break;
    }

    case 0x20:
    {
      ledline1.setBrightness(255);
      ledline2.setBrightness(255);
      ledline3.setBrightness(255);
      fadeAllOff(1);
      break;
    }
    case 'q':
    {
      mode_flg = false;
      sendResponce();
      Serial_flush();
      Serial.println("Quit LEMONMODE");
      break;
    }
    }
  }
}

void TOKKIMODE(void){
  Serial.println("TOKKIモードにはいりました。");
  Serial.println("入り方：");
  Serial.println("");
  mode_flg = true;
  uint8_t num = 0;
  int32_t i = 0;
  char str = 0;

  while (mode_flg)
  {
    if (Serial.available() > 0)
    {
      str = Serial.read();
    }
    else
      str = 0; //なにも来てなかったら何も動かさない
    switch (str)
    {
      case '0':
      {
        patAllOn(255, 255, 0);
        sendResponce();
        break;
      }
      case '1':
      {
        fadeChange(0, 0, 255, 20);
        sendResponce();
        break;
      }
      case '2':
      {
        patAllOn(255, 0, 0);
        sendResponce();
        break;
      }
      case '3':
      {
        fadeChange(255, 255, 0, 20);
        sendResponce();
        break;
      }
      case '4':
      {
        patAllOn(0,0,255);
        sendResponce();
        break;
      }

      case '5':
      {
        fadeChange(50, 0, 0, 10);
        sendResponce();
        break;
      }

      case '6':
      {
        fadeAllOff(50);
        sendResponce();
        break;
      }

      case '7':
      {
        rainbowCycle(10);
        break;
      }

      case 8:{
        patAllOff();
        Serial.println("end of program. please quit to q");
        break;
      }

      case 0x20:
      {
        fadeAllOff(3);
        break;
      }

      case 'q':
      {
        mode_flg = false;
        sendResponce();
        Serial_flush();
        Serial.println("Quit TOKKIMODE");
      }
    }
  }
}

void setup(){
  pinMode(PSW1, INPUT_PULLUP);
  pinMode(PSW2, INPUT_PULLUP);
  pinMode(DEBUG_LED, OUTPUT);
  Serial.begin(115200);
  specialCode();
  ledline1.begin();
  ledline2.begin();
  ledline3.begin();
  ledline1.show(); // Initialize all pixels to 'off'
  ledline2.show(); // Initialize all pixels to 'off'
  ledline3.show(); // Initialize all pixels to 'off'

  patAllOff();
  Serial.println("KOE_LED System TestRev.5 Started!");

  mode = '0';
}

void loop(){

  switch (mode)
  {
  case '0':
  { //スタート分岐
    Serial.println("fadeAllOff.");
    fadeAllOff(10);
    ledShow();
    Serial.println("fadeAllOff. Waiting mode commands.");
    Serial.println("  '0':  Turn Off.....すべてOFF、コマンド待ちモード");
    Serial.println("  '1':  All test.....動作確認モード");
    Serial.println("  '2':  Press mode...押している間だけ光るモードに切り替え");
    Serial.println("  '3':  あすかが突然パニックモード");
    Serial.println("  '4':  微生物モード");
    Serial.println("  '5':  勇者御一行モード");
    Serial.println("  '6':  LemonSquashモード");
    Serial.println("  '7':  GROOOOOOTモード");
    Serial.println("  '8':  ロリポップモード");
    Serial.flush();
    delay(200);
    Serial.println("  '9':  LEAKモード");
    Serial.println("  '-':  特別企画モード");
    Serial.println("Space: Space mode enable...ふわっと光らせるモードに切り替え");
    Serial.flush();
    mode = SerialWaitRead();
    Serial_flush();
    break;
  }

  case '1':
  { //All test動作確認モード
    Serial.println("Do you want to Really start All test?");
    Serial.println("y or n");
    while (Serial.available() <= 0)
      ;
    char rcv = Serial.read();
    if (rcv == 'y')
    {
      colorWipe(ledline1.Color(255, 0, 0), 20);     // Red
      colorWipe(ledline1.Color(0, 255, 0), 20);     // Green
      colorWipe(ledline1.Color(0, 0, 255), 20);     // Blue
      colorWipe(ledline1.Color(255, 255, 255), 20); // White RGBW
      // Send a theater pixel chase in...
      theaterChase(ledline1.Color(255, 255, 255), 20); // White
      theaterChase(ledline1.Color(255, 0, 0), 20);     // Red
      theaterChase(ledline1.Color(0, 255, 0), 20);     // green
      theaterChase(ledline1.Color(0, 0, 255), 20);     // Blue
      rainbow(10);
      rainbowCycle(10);
      theaterChaseRainbow(20);
      mode = '0';
      Serial.println("End mode = 0");
    }
    else if (rcv == 'n')
    {
      Serial.println("Exit mode=0");
      mode = '0';
    }
    else
    {
      Serial.println("Send y or n");
    }
    break;
  }

  case '2':
  { //patOnテストモード
    Serial.println("Press mode Selected.");
    Serial.println("Send colors: ");
    Serial.println("        red: r");
    Serial.println("       blue: b");
    Serial.println("      green: g");
    Serial.println("     orange: o");
    Serial.println("     yellow: y");
    Serial.println("       pink: p");
    Serial.println("      white: w");
    Serial.println("        off: Space bar");
    Serial.println();
    Serial.println("       quit: q");

    pressmode = true;
    char rcv = 0x20;
    while (pressmode)
    {
      rcv = SerialWaitRead();
      Serial_flush();
      if (rcv == 'q')
      {
        pressmode = false;
        mode = '0'; //Off mode
        Serial_flush();
        Serial.println("Quit, mode = 0");
      }
      else if (rcv == 'r')
      {
        patAllOn(255, 0, 0);
        Serial_flush();
        // Red
      }
      else if (rcv == 'g')
      {
        patAllOn(0, 255, 0);
        Serial_flush();
        // Green
      }
      else if (rcv == 'b')
      {
        patAllOn(0, 0, 255);
        Serial_flush();
        // Blue
      }
      else if (rcv == 'o')
      {
        patAllOn(255, 165, 0);
        Serial_flush();
        // Orange
      }
      else if (rcv == 'y')
      {
        patAllOn(255, 255, 0);
        Serial_flush();
        // Yellow
      }
      else if (rcv == 'w')
      {
        patAllOn(255, 255, 255);
        Serial_flush();
        // White
      }
      else if (rcv == 'p')
      {
        patAllOn(255, 0, 255);
        Serial_flush();
      }
      else if (rcv == 0x20)
      {
        patAllOff();
        Serial_flush();
      }
      else if (rcv == 'a')
      {
        patOnLine(255, 255, 255, 3);
        Serial_flush();
      }
    }
    Serial.println("Exit Press mode");
    mode = '0';
    break;
  }

  case '3':
  { //アスパニモード
    char rcv = 0;
    Serial.println();
    Serial.println();
    Serial.println();
    Serial.println("あすかが突然パニック");
    Serial.println("REALLY? y or n");
    rcv = SerialWaitRead();
    Serial_flush();
    if (rcv == 'y')
    {
      ASUPANIMODE();
      Serial.println("End ASUPANIMODE mode = '0';");
      mode = '0';
    }
    else
    {
      mode = '0';
      Serial.println("Quit ASUPANIMODE mode = 0;");
      Serial.println(mode, HEX);
    }
    break;
  }

  case '4':
  { //微生物モード
    Serial.println();
    Serial.println();
    Serial.println();
    Serial.println("微生物モード");
    Serial.println("REALLY? y or n");
    char rcv = SerialWaitRead();
    Serial_flush();
    if (rcv == 'y')
    {
      BISEIBUTSUMODE();
      Serial.println("Quit BISEIBUTSUMODE mode = '0';");
      mode = '0';
    }
    else
    {
      mode = '0';
      Serial.println("Quit BISEIBUTSUMODE mode = 0;");
    }
    break;
  }

  case '5':
  { //勇者御一行モード
    Serial.println();
    Serial.println();
    Serial.println();
    Serial.println("勇者御一行");
    Serial.println("REALLY? y or n");
    char rcv = SerialWaitRead();
    Serial_flush();
    if (rcv == 'y')
    {
      sendResponce();
      YUSHAMODE();
      Serial.println("Quit YUSHAMODE mode = '0';");
      mode = '0';
    }
    else
    {
      mode = '0';
      Serial.println("Quit YUSHAMODE mode = 0;");
    }
    break;
  }

  case '6':
  { //レモンスカッシュモード
    Serial.println();
    Serial.println();
    Serial.println();
    Serial.println("LemonSquashモード");
    Serial.println("REALLY? y or n");
    char rcv = SerialWaitRead();
    Serial_flush();
    if (rcv == 'y')
    {
      sendResponce();
      LEMONMODE();
      Serial.println("Quit YUSHAMODE mode = '0';");
      mode = '0';
    }
    else
    {
      mode = '0';
      Serial.println("Quit YUSHAMODE mode = 0;");
    }
    break;
  }

  case '7':
  { //GrootひさBlue
    Serial.println();
    Serial.println();
    Serial.println();
    Serial.println("Groooootモード");
    Serial.println("REALLY? y or n");
    char rcv = SerialWaitRead();
    Serial_flush();
    if (rcv == 'y')
    {
      sendResponce();
      GROOOOOOTMODE();
      Serial.println("Quit GROOOOOOTMODE mode = '0';");
      mode = '0';
    }
    else
    {
      mode = '0';
      Serial.println("Quit GROOOOOOTMODE mode = 0;");
    }
    break;
  }

  case '8':
  { //LOLLIPOPモード
    Serial.println();
    Serial.println();
    Serial.println();
    Serial.println("ロリポップモード");
    Serial.println("REALLY? y or n");
    char rcv = SerialWaitRead();
    if (rcv == 'y')
    {
      LOLLIPOPMODE();
      Serial.println("Quit LOLLIPOPMODE mode = '0';");
      mode = '0';
    }
    else
    {
      mode = '0';
      Serial.println("Quit LOLLIPOPMODE mode = 0;");
    }
    break;
  }

  case '9':
  { //LEAKモード
    Serial.println();
    Serial.println();
    Serial.println();
    Serial.println("LEAKモード");
    Serial.println("REALLY? y or n");
    char rcv = SerialWaitRead();
    if (rcv == 'y')
    {
      LEAKMODE();
      Serial.println("Quit LEAKMODE mode = '0';");
      mode = '0';
    }
    else
    {
      mode = '0';
      Serial.println("Quit LEAKMODE mode = 0;");
    }
  }

  case 0x20:
  { //fadeChangeテスト
    Serial.println("0x20 space mode Selected.");
    Serial.println("Send colors: ");
    Serial.println("        red: r");
    Serial.println("       blue: b");
    Serial.println("      green: g");
    Serial.println("     orange: o");
    Serial.println("     yellow: y");
    Serial.println("     pink  : p");
    Serial.println("      white: w");
    Serial.println("        off: Space bar");
    Serial.println();
    Serial.println("       quit: q");
    char rcv;
    spacemode = true;
    while (spacemode)
    {
      rcv = SerialWaitRead();
      Serial_flush();
      if (rcv == 'q')
      {
        spacemode = false;
        Serial_flush();
        mode = '0';
      }
      else if (rcv == 'r')
      {
        fadeChange(255, 0, 0, 50);
        Serial_flush();
        // Red
      }
      else if (rcv == 'g')
      {
        fadeChange(0, 255, 0, 50);
        Serial_flush();
        // Green
      }
      else if (rcv == 'b')
      {
        fadeChange(0, 0, 255, 50);
        Serial_flush();
        // Blue
      }
      else if (rcv == 'o')
      {
        fadeChange(255, 5, 0, 50);
        Serial_flush();
        // Orange
      }
      else if (rcv == 'y')
      {
        fadeChange(255, 255, 0, 50);
        Serial_flush();
        // Yellow
      }
      else if (rcv == 'w')
      {
        fadeChange(254, 254, 254, 50);
        Serial_flush();
        // White
      }
      else if (rcv == 'p')
      {
        fadeChange(255, 0, 255, 50);
        Serial_flush();
        //pink
      }
      else if (rcv == 0x20)
      {
        fadeAllOff(6);
        Serial_flush();
      }
      else if (rcv == 'q')
      {
        patAllOff();
        Serial_flush();
        spacemode = false;
        mode = '0';
        //pink
      }
    }
    Serial.println("Exit Spacemode");
    mode = '0';
    Serial.println("mode = 0x30");
    Serial.println(mode);
    break;
  }

  case '-':
  {
    Serial.println();
    Serial.println();
    Serial.println();
    Serial.println("特別企画モード");
    Serial.println("REALLY? y or n");
    char rcv = SerialWaitRead();
    if (rcv == 'y')
    {
      TOKKIMODE();
      Serial.println("Quit TOKKIMODE mode = '0';");
      mode = '0';
    }
    else
    {
      mode = '0';
      Serial.println("Quit TOKKIMODE mode = 0;");
    }
    break;
  }

  default:
  {
    Serial_flush();
    mode = '0';
    break;
  }
  }
}
